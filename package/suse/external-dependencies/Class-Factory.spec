#
#   - Class::Factory -
#   This spec file was automatically generated by cpan2rpm [ver: 2.027]
#   The following arguments were used:
#       --spec-only --version=1.04 '--author=Fred Moyer' Class-Factory-1.04.tar.gz
#   For more information on cpan2rpm please visit: http://perl.arix.com/
#

%define pkgname Class-Factory
%define filelist %{pkgname}-%{version}-filelist
%define NVR %{pkgname}-%{version}-%{release}
%define maketest 1

name:      perl-Class-Factory
summary:   Class-Factory - Useful base class for factory classes
version:   1.04
release:   1
vendor:    Fred Moyer
packager:  Arix International <cpan2rpm@arix.com>
license:   Artistic
group:     Applications/CPAN
url:       http://www.cpan.org
buildroot: %{_tmppath}/%{name}-%{version}-%(id -u -n)
buildarch: noarch
prefix:    %(echo %{_prefix})
source:    Class-Factory-1.04.tar.gz

%description
This is a simple module that factory classes can use to generate new
types of objects on the fly, providing a consistent interface to
common groups of objects.

Factory classes are used when you have different implementations for
the same set of tasks but may not know in advance what implementations
you will be using. Configuration files are a good example of
this. There are four basic operations you would want to do with any
configuration: read the file in, lookup a value, set a value, write
the file out. There are also many different types of configuration
files, and you may want users to be able to provide an implementation
for their own home-grown configuration format.

With a factory class this is easy. To create the factory class, just
subclass "Class::Factory" and create an interface for your
configuration serializer. "Class::Factory" even provides a simple
constructor for you. Here's a sample interface and our two built-in
configuration types:

 package My::ConfigFactory;
 
 use strict;
 use base qw( Class::Factory );
 
 sub read  { die "Define read() in implementation" }
 sub write { die "Define write() in implementation" }
 sub get   { die "Define get() in implementation" }
 sub set   { die "Define set() in implementation" }
 
 __PACKAGE__->add_factory_type( ini  => 'My::IniReader' );
 __PACKAGE__->add_factory_type( perl => 'My::PerlReader' );
 
 1;

And then users can add their own subclasses:

 package My::CustomConfig;
 
 use strict;
 use base qw( My::ConfigFactory );
 
 sub init {
     my ( $self, $filename, $params ) = @_;
     if ( $params->{base_url} ) {
         $self->read_from_web( join( '/', $params->{base_url}, $filename ) );
     }
     else {
         $self->read( $filename );
     }
     return $self;
 }
 
 sub read  { ... implementation to read a file ... }
 sub write { ... implementation to write a file ...  }
 sub get   { ... implementation to get a value ... }
 sub set   { ... implementation to set a value ... }
 
 sub read_from_web { ... implementation to read via http ... }
 
 # Now register my type with the factory
 
 My::ConfigFactory->add_factory_type( 'mytype' => __PACKAGE__ );
 
 1;

(You may not wish to make your factory the same as your interface, but
this is an abbreviated example.)

So now users can use the custom configuration with something like:

 #!/usr/bin/perl
 
 use strict;
 use My::ConfigFactory;
 use My::CustomConfig;   # this adds the factory type 'custom'...
 
 my $config = My::ConfigFactory->new( 'custom', 'myconf.dat' );
 print "Configuration is a: ", ref( $config ), "\n";

Which prints:

 Configuration is a My::CustomConfig

And they can even add their own:

 My::ConfigFactory->register_factory_type( 'newtype' => 'My::New::ConfigReader' );

This might not seem like a very big win, and for small standalone
applications probably isn't. But when you develop large applications
the "(add|register)_factory_type()" step will almost certainly be
done at application initialization time, hidden away from the eyes of
the application developer. That developer will only know that she can
access the different object types as if they are part of the system.

As you see in the example above implementation for subclasses is very
simple -- just add "Class::Factory" to your inheritance tree and you
are done.

#
# This package was generated automatically with the cpan2rpm
# utility.  To get this software or for more information
# please visit: http://perl.arix.com/
#

%prep
%setup -q -n %{pkgname}-%{version} 
chmod -R u+w %{_builddir}/%{pkgname}-%{version}

%build
grep -rsl '^#!.*perl' . |
grep -v '.bak$' |xargs --no-run-if-empty \
%__perl -MExtUtils::MakeMaker -e 'MY->fixin(@ARGV)'
CFLAGS="$RPM_OPT_FLAGS"
%{__perl} Makefile.PL `%{__perl} -MExtUtils::MakeMaker -e ' print qq|PREFIX=%{buildroot}%{_prefix}| if \$ExtUtils::MakeMaker::VERSION =~ /5\.9[1-6]|6\.0[0-5]/ '`
%{__make} 
%if %maketest
%{__make} test
%endif

%install
[ "%{buildroot}" != "/" ] && rm -rf %{buildroot}

%{makeinstall} `%{__perl} -MExtUtils::MakeMaker -e ' print \$ExtUtils::MakeMaker::VERSION <= 6.05 ? qq|PREFIX=%{buildroot}%{_prefix}| : qq|DESTDIR=%{buildroot}| '`

cmd=/usr/share/spec-helper/compress_files
[ -x $cmd ] || cmd=/usr/lib/rpm/brp-compress
[ -x $cmd ] && $cmd

# SuSE Linux
if [ -e /etc/SuSE-release -o -e /etc/UnitedLinux-release ]
then
    %{__mkdir_p} %{buildroot}/var/adm/perl-modules
    %{__cat} `find %{buildroot} -name "perllocal.pod"`  \
        | %{__sed} -e s+%{buildroot}++g                 \
        > %{buildroot}/var/adm/perl-modules/%{name}
fi

# remove special files
find %{buildroot} -name "perllocal.pod" \
    -o -name ".packlist"                \
    -o -name "*.bs"                     \
    |xargs -i rm -f {}

# no empty directories
find %{buildroot}%{_prefix}             \
    -type d -depth                      \
    -exec rmdir {} \; 2>/dev/null

%{__perl} -MFile::Find -le '
    find({ wanted => \&wanted, no_chdir => 1}, "%{buildroot}");
    print "%doc  Changes README";
    for my $x (sort @dirs, @files) {
        push @ret, $x unless indirs($x);
        }
    print join "\n", sort @ret;

    sub wanted {
        return if /auto$/;

        local $_ = $File::Find::name;
        my $f = $_; s|^\Q%{buildroot}\E||;
        return unless length;
        return $files[@files] = $_ if -f $f;

        $d = $_;
        /\Q$d\E/ && return for reverse sort @INC;
        $d =~ /\Q$_\E/ && return
            for qw|/etc %_prefix/man %_prefix/bin %_prefix/share|;

        $dirs[@dirs] = $_;
        }

    sub indirs {
        my $x = shift;
        $x =~ /^\Q$_\E\// && $x ne $_ && return 1 for @dirs;
        }
    ' > %filelist

[ -z %filelist ] && {
    echo "ERROR: empty %files listing"
    exit -1
    }

%clean
[ "%{buildroot}" != "/" ] && rm -rf %{buildroot}

%files -f %filelist
%defattr(-,root,root)

%changelog
* Thu Nov 23 2006 root@dca02
- Initial build.